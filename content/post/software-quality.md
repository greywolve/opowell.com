+++
date = "2016-11-16T09:20:27+02:00"
title = "Software Quality: A new definition"
tags = ["software quality"]
+++

> Software does not run in a magic fairy aether powered by the fevered dreams of CS PhDs.
>
> -- <cite>Mike Acton</cite>

Recently I've come to adopt a new definition for what I consider quality
software. It's really three primary things:

1. It solves the problem you set out to solve, and ideally, *ONLY* that problem.
2. It does so, while *efficiently* using the hardware underneath you.
3. It is written in a reasonable amount of time

1 forces you to intimately understand your problem. This is the key to not only
coming up with a good solution, but also not creating more problems which you
don't actually need to solve. Mike Acton would say that you also need to
understand the cost of solving your problem, in addition to the problem itself -
otherwise you don't actually understand the problem in the first place.

2 is less about saving money, or increasing revenue (from faster response
times), than it is about simply not being wasteful of our planet's resources
(software doesn't run on fresh air), or your user's time. Over the last three
decades computers have become an order of magnitude faster, but can we say
that software today feels an order of magnitude more responsive?

3 is important for more reasons that simply needing to release on time. You
have a finite amount of hours in your life, and a finite amount of projects that
you can complete in your lifetime. Not to mention that you'd probably also want
to have a life outside of code.

These goals are complementary in many ways. Caring about hours of your life
spent coding, means that you ruthlessly have to cut out any anything that doesn't
actually solve your problem. This more than likely leads to better software
performance and efficiency from less code bloat alone.
